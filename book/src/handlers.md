# Handlers
Handlers enable processes to react to incoming messages. By using the `#[handler]` proc macro, you define how a process should handle different types of messages. A corresponding implementation fo the trait `Handler<M>` (`M` being the handled message) will be generated by the macro.

## Implementing a Handler
To implement a `Handler`, annotate a method with `#[handler]`. This method must conform to one of two possible signatures:

- **Basic Form:** `async fn my_method(&mut self, msg: M) -> Reply<T, E>`
- **With Context:** `async fn my_method(&mut self, msg: M, ctx: &Ctx<Self>) -> Reply<T, E>`

`M` is the type of the incoming message, `T` is the type of the successful reply, and `E` is the type of error.

```rust
use speare::*;

struct MessageToSelf(u64);

struct MyProc;

#[process]
impl MyProc {
    #[handler]
    async fn no_ctx(&mut self, msg: MessageToSelf) -> Reply<u64, String> {
        if msg.0 < 20 {
            return Err("should be higher than 20".to_string());
        }

        reply(msg.0)
    }

    #[handler]
    async fn with_ctx(&mut self, msg: (), ctx: &Ctx<Self>) -> Reply<(), ()> {
        ctx.tell(ctx.this(), MessageToSelf(10)).await;
        reply(())
    }
}
```

The optional `Ctx<Self>` argument provides additional capabilities, among them:

- `ctx.this()`: Returns the `Pid<P>` of the current process.
- Message Passing: `Ctx<P>` has `.tell()`, `.tell_in()`, and `.ask()` methods, same as `Node`, for sending and asking for messages.
- [Deferring replies](./reply.md#deferring-replies) and `Process` [monitoring](./lifecycle_management.md#monitoring-processes), both which will be talked about later in the book.


The `Reply<T, E>` type is an alias for `Result<Option<T>, E>`. When replying to a message, use the `reply()` function for convenience. You can read more about this [in the following section of the book](./reply.md), which talks about it in more detail.

## Message Passing Methods: `.tell`, `.tell_in`, and `.ask`
In `speare`, processes communicate using three primary methods: `.tell`, `.tell_in`, and `.ask`. These methods are available in both the `Node` and `Ctx<Self>` types.

- `.tell` (Fire and Forget): Send a message without expecting a response. The process handles the message and continues without sending back any data.
- `.tell_in` (Delayed Fire and Forget): Similar to `.tell`, but delays the message delivery by a specified duration.
- `.ask` (Request-Response): Send a message and await a response. This method is used when the sender process needs data back from the receiver.

One important distinction is that `.tell` and `.tell_in` will fail silently if the `Process` is no longer running. 

### Example Usage
```rust
#[tokio::main]
async fn main() {
    let node = Node::default();
    let dog_pid = node.spawn(Dog::new()).await;

    // Fire and forget
    node.tell(&dog_pid, Bark).await;

    // Fire and forget after 10 milliseconds
    node.tell_in(&dog_pid, GiveBone, Duration::from_millis(10)).await;

    // Request response
    let greeting = node.ask(&dog_pid, SayHi).await.unwrap_or_else(|_| "".to_string());
    println!("The dog says: {}", greeting);
}

```